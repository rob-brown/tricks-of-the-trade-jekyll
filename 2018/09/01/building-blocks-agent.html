<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Building Blocks: Agent | Tricks of the Trade</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Building Blocks: Agent" />
<meta name="author" content="Robert Brown" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve long been an advocate of simple building blocks that are trivial to understand and implement. Despite their small size, they enable simpler development. Many that I have written are published on my GitHub account. Today I want to share my most used building block: Agent." />
<meta property="og:description" content="I’ve long been an advocate of simple building blocks that are trivial to understand and implement. Despite their small size, they enable simpler development. Many that I have written are published on my GitHub account. Today I want to share my most used building block: Agent." />
<link rel="canonical" href="/2018/09/01/building-blocks-agent.html" />
<meta property="og:url" content="/2018/09/01/building-blocks-agent.html" />
<meta property="og:site_name" content="Tricks of the Trade" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-01T03:24:00+00:00" />
<script type="application/ld+json">
{"datePublished":"2018-09-01T03:24:00+00:00","author":{"@type":"Person","name":"Robert Brown"},"dateModified":"2018-09-01T03:24:00+00:00","description":"I’ve long been an advocate of simple building blocks that are trivial to understand and implement. Despite their small size, they enable simpler development. Many that I have written are published on my GitHub account. Today I want to share my most used building block: Agent.","url":"/2018/09/01/building-blocks-agent.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/2018/09/01/building-blocks-agent.html"},"headline":"Building Blocks: Agent","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tricks of the Trade" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Tricks of the Trade</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a><a class="page-link" href="/hire-me">Hire Me</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Building Blocks: Agent</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-09-01T03:24:00+00:00" itemprop="datePublished">Sep 1, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Robert Brown</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I’ve long been an advocate of simple building blocks that are trivial to understand and implement. Despite their small size, they enable simpler development. Many that I have written are published on my <a href="https://github.com/rob-brown">GitHub account</a>. Today I want to share my most used building block: <code class="language-plaintext highlighter-rouge">Agent</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Agent</code> comes from <a href="https://hexdocs.pm/elixir/Agent.html">Elixir’s module of the same name</a>. It is a thread-safe encapsulation around arbitrary state. Since I use <code class="language-plaintext highlighter-rouge">Agent</code> all the time in Elixir, I found myself wanting for it in other languages.</p>

<p>So, let’s implement an agent in Swift. Here is the basic type definition and constructor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Foundation

public final class SimpleAgent&lt;State&gt; {
    private var state: State
    private let queue: DispatchQueue

    public init(state: State) {
        self.state = state
        self.queue = DispatchQueue(label: "pro.tricksofthetrade.SimpleAgent", qos: .userInitiated)
    }
}
</code></pre></div></div>

<p>We can see that <code class="language-plaintext highlighter-rouge">SimpleAgent</code> holds some generic state. It also has a <code class="language-plaintext highlighter-rouge">DispatchQueue</code>. This is where the thread safety comes in. I’m going to assume you are familiar enough with Grand Central Dispatch (GCD).</p>

<p>Before continuing, you should note that it’s best that <code class="language-plaintext highlighter-rouge">State</code> be immutable. I prefer to do this with a <code class="language-plaintext highlighter-rouge">struct</code> that only has <code class="language-plaintext highlighter-rouge">let</code> properties that are also immutable. Having immutable data makes it impossible to mutate the data in an unsafe way.</p>

<p>An agent effectively has two operations: get and set. Let’s start with getting data.</p>

<p>Fetching the data does the following:</p>

<ol>
  <li>Synchronously run a closure on the dispatch queue.</li>
  <li>Call the given closure with the current state.</li>
  <li>The closure returns the subset of data it wants.</li>
  <li>Return the result to the caller.</li>
</ol>

<p>And here is the code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public func fetch&lt;Result&gt;(closure: ((State) -&gt; Result)) -&gt; Result {
    var result: Result!
    queue.sync {
        result = closure(self.state)
    }
    return result
}
</code></pre></div></div>

<p>Note that an implicitly unwrapped optional must be used here because the Swift compiler is not yet smart enough to know that <code class="language-plaintext highlighter-rouge">result</code> is always written to before it is read.</p>

<p>Now for updating the state. It works similarly to the <code class="language-plaintext highlighter-rouge">fetch</code> function.</p>

<ol>
  <li>Asynchronously run a closure on the dispatch queue.</li>
  <li>Call the given closure with the current state.</li>
  <li>The closure returns the new data to store.</li>
  <li>Update the internal state.</li>
</ol>

<p>And here is the code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public func update(closure: @escaping (State) -&gt; State) {
    queue.async {
        self.state = closure(self.state)
    }
}
</code></pre></div></div>

<p>The code could just as easily use <code class="language-plaintext highlighter-rouge">queue.sync</code>. There’s no need to wait around for the update to complete, so <code class="language-plaintext highlighter-rouge">queue.async</code> is typically the desired behavior.</p>

<p>There is one more operation we need. There are times we want to both get and update the data. It is not safe for the caller to fetch the data, change it, then set it. That can lead to race conditions. So, let’s build an operation that does both at the same time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public func fetchAndUpdate&lt;Result&gt;(closure: (State) -&gt; (Result, State)) -&gt; Result {
    var result: Result!
    queue.sync {
        let (returnValue, newState) = closure(self.state)
        self.state = newState
        result = returnValue
    }
    return result
}
</code></pre></div></div>

<p>That’s it. In total, <code class="language-plaintext highlighter-rouge">SimpleAgent</code> is 36 lines of code, including blank lines. Any Swift developer should be able to look at this code and understand it within a few minutes. Plus you now have a powerful building block for building bigger building blocks such as actors, state machines, and futures. Or it can be used as is.</p>

  </div><a class="u-url" href="/2018/09/01/building-blocks-agent.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Tricks of the Trade</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Tricks of the Trade</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rob-brown"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">rob-brown</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Writing about best development practices and other topics.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
